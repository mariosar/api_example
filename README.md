# API EXAMPLE

This is a Rails API tutorial example code.

## Steps to reproduce this repository

Creating the project:
```
rails new api_test --api
bundle install
rake db:create
```

Add RSpec for testing and FactoryBot:

Add to `Gemfile` inside :test, :development group:
```
gem 'rspec-rails'
gem 'factory_bot_rails'
```

Since this is an API and we're serving JSON responses include:
```
gem 'active_model_serializers'
```

Run:
```
bundle install
rails g rspec:install # Install RSpec
```

'active_model_serializers' is great for defining *what* model attributes and relationships we'd like to respond with + accepts custom methods!

Tell our serializer to use [json:api](https://jsonapi.org/) standard for json responses. Click on the link to read more about it.

```
'ActiveModelSerializers.config.adapter = ActiveModelSerializers::Adapter::JsonApi' >> config/initializers/active_model_serializers.rb
```

At this point you may want to scaffold a `User` with `name email` and run `rails s` to do a quick test. Send a few requests and test it.
> You may find some browsers block CORS requests *even on localhost*

Our API wouldn't be very useful if other websites can't make CORS requests to it. You can read more about CORS [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), but for now let's add some middleware to allow CORS requests.

Add CORS support:
```
gem 'rack-cors'
bundle install
```

Read more about rack-cors gem at [https://github.com/cyu/rack-cors](https://github.com/cyu/rack-cors)

The CORS middleware will intercept requests and *allow* certain *request types* from certain *origins* to certain *resources*. We're gonna allow everything for now with the following code inside `application.rb`:

```
config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins '*'
    resource '*', headers: :any, methods: [:get, :post, :options]
  end
end
```

If your CORS Ajax requests were blocked before, try them now. In any website, open up the developer console and try to send a quick request to your API:
```
# Using jQuery:
$.ajax("http://localhost:3000/users")

# Plain Javascript:
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    console.log(this.responseText);
  }
};
xhttp.open("GET", "ajax_info.txt", true);
xhttp.send();
```

Another issue is limiting the usage of our API (throttling), protecting it from nasty things like [DoS Attack](https://en.wikipedia.org/wiki/Denial-of-service_attack), and logging data. For this we're gonna use a handy gem [rack-attack](https://github.com/kickstarter/rack-attack) brought to you by the nice people at [Kickstarter](https://www.kickstarter.com/)

```
gem 'rack-attack'
bundle install
```

Edit `application.rb` to include the Rack::Attack middleware:

```
config.middleware.use Rack::Attack
```

We've got RackAttack in our middleware stack, but now need to initialize it. We can safelist, blocklist, throttle, and track.
```
# config/initializers/rack_attack.rb

class Rack::Attack

  # `Rack::Attack` is configured to use the `Rails.cache` value by default,
  # but you can override that by setting the `Rack::Attack.cache.store` value
  Rack::Attack.cache.store = ActiveSupport::Cache::MemoryStore.new

  # Allow all local traffic
  safelist('allow-localhost') do |req|
    '127.0.0.1' == req.ip || '::1' == req.ip
  end

  # Allow an IP address to make 5 requests every 5 seconds
  throttle('req/ip', limit: 5, period: 5) do |req|
    req.ip
  end

  # Send the following response to throttled clients
  self.throttled_response = ->(env) {
    retry_after = (env['rack.attack.match_data'] || {})[:period]
    [
      429,
      {'Content-Type' => 'application/json', 'Retry-After' => retry_after.to_s},
      [{error: "Throttle limit reached. Retry later."}.to_json]
    ]
  }
end
```

The above is a basic setup. We're telling Rack::Attack to green light localhost, limit everyone to 5 requests per 5 seconds, and send back a custom message with 429 response if someone exceeds that.

> Try adding a throttling rule, remove localhost from the safelist, then hammer your api with consecutive requests and see the result.

So far so good, but now I'd really like to have this app hosted somewhere so it's not just running on my local machine.

rails g model user name email
rails g serializer user
rails g scaffold_controller api::v1::users --model-name=user
# The specs generated by scaffold don't really generate the correct code (paths and model will be incorrect)

# User cUrl to make requests
curl -X GET -H "Accept: application/json" "localhost:3000/api/v1/users"
curl -X POST -H "Accept: application/json" -H "Content-Type: application/json" -d '{"user": {"name": "Mario", "email": "mario@gmail.com"}}' "localhost:3000/api/v1/users"
curl -X PUT ation/json" -H "Content-Type: application/json" -d '{"email": "mariosar@gmail.com"}' "localhost:3000/api/v1/users/2"
curl -X DELETE "localhost:3000/api/v1/users/1"

### Deployment to HEROKU

# Switch to PG
remove gem 'sqlite3'
add gem 'pg'
# In database.yml -> change:
# adapter: postgresql
# host: localhost
# encoding: unicode
# database: api_example_<env>
# username: api_example
# password: your_password

# Terminal
# sudo -u postgres psql
# create database api_example_<env>
# create user api_example with encrypted password 'secretpass';
# grant all privileges on database api_example_development to api_example;
# alter database <dbname> owner to <user>;
# alter user <user> createdb;

rake db:migrate

# Install Heroku CLI
# https://devcenter.heroku.com/articles/heroku-cli#download-and-install
# curl https://cli-assets.heroku.com/install-ubuntu.sh | sh
# heroku login
# heroku create
# git config --list
# git push heroku master

# heroko dyno interactive shell session 
# heroku run bash

# heroku run rake db:migrate

# Not sure about this command
# heroku ps:scale web=1

# heroku ps

# heroku open (opens your app on the browser)
# heroku logs
# heroku logs --tail
# heroku run rails console
# heroku run rake etc...

# Tell Heroku how to start the app using Procfile
# echo 'web: bundle exec puma -t 5:5 -p ${PORT:-3000} -e ${RACK_ENV:-development}' >> Procfile
# Or else it will just run your app is running rails s (but this is not suitable for production)
# Run heroku local and you will start your web server by executing the command in your Procfile


# Useful Heroku Links:
# https://devcenter.heroku.com/articles/getting-started-with-rails5
# https://devcenter.heroku.com/articles/procfile
# https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server
# https://devcenter.heroku.com/articles/config-vars
# https://devcenter.heroku.com/articles/connecting-to-heroku-postgres-databases-from-outside-of-heroku

